import { mapType } from '../../types/type-mapper';
import { DataSource } from '../../types/data-source-config';
import TableService from './tableService';
import { mapKeys, camelCase } from 'lodash';
class PostgresService extends TableService {
  constructor() {
    super();
    this.sourceType = DataSource.Postgres;
  }

  async getTables(sourceId: number) {
    const client = this.getClient(sourceId);
    try {
      const result = await client('information_schema.tables')
        .select('table_name')
        .where('table_schema', 'public');

      return result
        .map((row) => row.table_name)
        .filter((table) => this.isTableAccessible(sourceId, table));
    } catch (error) {
      console.error('Error fetching tables:', error);
      throw new Error('Failed to fetch tables');
    }
  }

  async getTableStructure(sourceId: number, table: string) {
    const client = this.getClient(sourceId);

    const result = await client('information_schema.columns')
      .select('column_name', 'data_type', 'is_nullable', 'column_default')
      .where('table_name', table);

    const foreignKeys = await client.raw(
      `SELECT kcu.column_name, ccu.table_name AS foreign_table, ccu.column_name AS foreign_column 
       FROM information_schema.table_constraints AS tc 
       JOIN information_schema.key_column_usage AS kcu
           ON tc.constraint_name = kcu.constraint_name
       JOIN information_schema.constraint_column_usage AS ccu
           ON ccu.constraint_name = tc.constraint_name
       WHERE tc.constraint_type = 'FOREIGN KEY' AND tc.table_name=:tableName;`,
      { tableName: table }
    );

    const primaryKeys = await client.raw(
      `SELECT kcu.column_name 
       FROM information_schema.table_constraints tc
       JOIN information_schema.key_column_usage kcu
           ON tc.constraint_name = kcu.constraint_name
       WHERE tc.constraint_type = 'PRIMARY KEY' AND tc.table_name = :tableName;`,
      { tableName: table }
    );

    const primaryKeyColumns = primaryKeys.rows.map((row) => row.column_name);

    return result.map((row) => {
      const foreignKey = foreignKeys.rows.find(
        (fk) => fk.column_name === row.column_name
      );
      return {
        name: row.column_name,
        type: mapType(row.data_type, DataSource.Postgres),
        isNullable: row.is_nullable === 'YES',
        default: row.column_default,
        constraints: {
          primaryKey: primaryKeyColumns.includes(row.column_name),
          foreignKey: foreignKey
            ? mapKeys(foreignKey, (_, k) => camelCase(k))
            : null,
        },
        isAutoGenerated: /nextval\(/i.test(row.column_default),
      };
    });
  }
}

export default PostgresService;

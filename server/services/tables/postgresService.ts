import { mapType } from '../../types/type-mapper';
import { DataSource } from '../../types/data-source-config';
import TableService from './tableService';

class PostgresService extends TableService {
  constructor(dbConfig: any) {
    super(dbConfig, 'pg');
  }

  async getTables() {
    try {
      const result = await this.db('information_schema.tables')
        .select('table_name')
        .where('table_schema', 'public');

      return result
        .map((row) => row.table_name)
        .filter((table) => this.isTableAccessible(table));
    } catch (error) {
      console.error('Error fetching tables:', error);
      throw new Error('Failed to fetch tables');
    }
  }

  async getTableStructure(table: string) {
    const result = await this.db('information_schema.columns')
      .select('column_name', 'data_type', 'is_nullable', 'column_default')
      .where('table_name', table);

    const foreignKeys = await this.db.raw(
      `SELECT kcu.column_name, ccu.table_name AS foreign_table, ccu.column_name AS foreign_column 
       FROM information_schema.table_constraints AS tc 
       JOIN information_schema.key_column_usage AS kcu
           ON tc.constraint_name = kcu.constraint_name
       JOIN information_schema.constraint_column_usage AS ccu
           ON ccu.constraint_name = tc.constraint_name
       WHERE tc.constraint_type = 'FOREIGN KEY' AND tc.table_name=:tableName;`,
      { tableName: table }
    );

    const primaryKeys = await this.db.raw(
      `SELECT kcu.column_name 
       FROM information_schema.table_constraints tc
       JOIN information_schema.key_column_usage kcu
           ON tc.constraint_name = kcu.constraint_name
       WHERE tc.constraint_type = 'PRIMARY KEY' AND tc.table_name = :tableName;`,
      { tableName: table }
    );

    const primaryKeyColumns = primaryKeys.rows.map((row) => row.column_name);

    return result.map((row) => ({
      name: row.column_name,
      type: mapType(row.data_type, DataSource.Postgres),
      isNullable: row.is_nullable === 'YES',
      default: row.column_default,
      constraints: {
        primaryKey: primaryKeyColumns.includes(row.column_name),
        foreignKey:
          foreignKeys.rows.find((fk) => fk.column_name === row.column_name) ||
          null,
      },
      isAutoGenerated: /nextval\(/i.test(row.column_default),
    }));
  }
}

export default PostgresService;

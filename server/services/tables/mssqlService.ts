import TableService, { GetRowsOptions } from './tableService';
import { mapType } from '../../types/type-mapper';
import { DataSource } from '../../types/data-source-config';

class MssqlService extends TableService {
  constructor() {
    super();
    this.sourceType = DataSource.MSSQL;
  }

  async getTableStructure(sourceId: number, table: string) {
    const client = this.getClient(sourceId);
    const config = this.getCurrentConfig(sourceId);
    const result = await client.raw(
      `
      SELECT COLUMN_NAME AS column_name, DATA_TYPE AS data_type, IS_NULLABLE AS is_nullable, COLUMN_DEFAULT AS column_default
      FROM INFORMATION_SCHEMA.COLUMNS
      WHERE TABLE_NAME = ?`,
      [table]
    );

    const foreignKeys = await client.raw(
      `
      SELECT k.COLUMN_NAME AS column_name, fk.TABLE_NAME AS foreign_table, fk.COLUMN_NAME AS foreign_column
      FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE k
      JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS rc ON k.CONSTRAINT_NAME = rc.CONSTRAINT_NAME
      JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE fk ON rc.UNIQUE_CONSTRAINT_NAME = fk.CONSTRAINT_NAME
      WHERE k.TABLE_NAME = ?`,
      [table]
    );

    const primaryKeys = await client.raw(
      `
      SELECT COLUMN_NAME AS column_name
      FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE
      WHERE OBJECTPROPERTY(OBJECT_ID(CONSTRAINT_SCHEMA + '.' + CONSTRAINT_NAME), 'IsPrimaryKey') = 1
      AND TABLE_NAME = ?`,
      [table]
    );

    const identityColumns = await client.raw(
      `
      SELECT COLUMN_NAME 
      FROM INFORMATION_SCHEMA.COLUMNS 
      WHERE TABLE_NAME = ? 
      AND COLUMNPROPERTY(OBJECT_ID(TABLE_SCHEMA + '.' + TABLE_NAME), COLUMN_NAME, 'IsIdentity') = 1`,
      [table]
    );

    const primaryKeyColumns = primaryKeys.map((row) => row.column_name);

    return result.map((row) => ({
      name: row.column_name,
      type: mapType(row.data_type, DataSource.MSSQL),
      isNullable: row.is_nullable === 'YES',
      default: row.column_default,
      constraints: {
        primaryKey: primaryKeyColumns.includes(row.column_name),
        foreignKey:
          foreignKeys.find((fk) => fk.column_name === row.column_name) || null,
      },
      isAutoGenerated:
        primaryKeyColumns.includes(row.column_name) &&
        config.tables.find((t) =>
          new RegExp(t.pattern.replace(/\*/g, '.*')).test(table)
            ? t.id_autogenerated
            : false
        ),
    }));
  }

  async getTables(sourceId: number) {
    try {
      const client = this.getClient(sourceId);
      const config = this.getCurrentConfig(sourceId);
      const result = await client
        .select('TABLE_NAME')
        .from('INFORMATION_SCHEMA.TABLES')
        .where('TABLE_CATALOG', config.database)
        .andWhere('TABLE_TYPE', 'BASE TABLE');

      return result
        .map((row) => row.TABLE_NAME)
        .filter((table) => this.isTableAccessible(sourceId, table));
    } catch (error) {
      console.error('Error fetching tables:', error);
      throw new Error('Failed to fetch tables');
    }
  }

  async getRows(sourceId: number, table: string, options: GetRowsOptions = {}) {
    const client = this.getClient(sourceId);
    let query = client(table).select('*');

    if (options.filterBy) {
      options.filterBy.forEach(({ column, operator = '=', value }) => {
        if (operator === 'IN' && Array.isArray(value)) {
          query = query.whereIn(column, value);
        } else if (operator === 'LIKE' || operator === 'ILIKE') {
          // Handle case-insensitive LIKE for MSSQL
          const convertedColumn = `CONVERT(VARCHAR(255), ??)`;
          query = query.whereRaw(`${convertedColumn} ${operator} ?`, [
            column,
            value,
          ]);
        } else {
          query = query.where(column, operator, value);
        }
      });
    }

    if (options.orderBy) {
      query = query.orderBy(
        options.orderBy.column,
        options.orderBy.direction || 'ASC'
      );
    }

    // MSSQL 2012+ requires ORDER BY when using OFFSET and FETCH NEXT
    if (options.limit || options.offset) {
      if (!options.orderBy) {
        query = query.orderByRaw('(SELECT NULL)'); // Ensures ORDER BY exists to avoid errors
      }
    }

    if (options.limit) query = query.limit(options.limit);
    if (options.offset) query = query.offset(options.offset);

    return await query;
  }
}

export default MssqlService;
